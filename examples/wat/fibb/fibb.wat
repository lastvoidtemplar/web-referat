(module
    ;; импортваме функция, която изчиства списъка от резултати
    ;; няма параметри и не връща нищо
    (import "js" "clear" (func $clear))
    ;; импортваме функция, която добавя число в списъка
    ;; от резултати
    (import "js" "print"  (func $print (param i32)))
    ;; декларираме функция, която смята
    ;; n-то числи на Фибоначи
    (func $fibb (param $n i32) (result i32)
        local.get $n    ;; бута n на стека
        i32.const 0     ;; бута константата 0 на стека
        i32.eq          ;; сравнява n и 0,ако n==0 бута 1, иначе бута 0

        local.get $n    ;; бута n на стека
        i32.const 1     ;; бута константата 1 на стека
        i32.eq          ;; сравнява n и 1,ако n==1 бута 1, иначе бута 0
                        ;; в момента на стека са резултата от n==0 и n==1
        i32.or          ;; прави or на тези двата резултата и го бута на стека

                        ;; проверява дали върха на стека е различен от 0. 
        if (result i32) ;; трябва да кажем какъв е резултата понеже wasm е типизиран
                        ;; тук влиза, ако n==0 || n==1
            i32.const 1 ;; бута 1 на стека и понеже if е последната инструкция, то и връща 1
        else
                        ;; тук влиза, ако не е в сприрачката на рекурсията
            local.get $n;; бута n на стека
            i32.const 1 ;; бута 1 на стека
            i32.sub     ;; смята n-1 и го слага на стека
            call $fibb  ;; прави рекурсивно извикване на fibb(n-1)

            local.get $n;; бута n на стека
            i32.const 2 ;; бута 2 на стека
            i32.sub     ;; смята n-2 и го слага на стека
            call $fibb  ;; прави рекурсивно извикване на fibb(n-2)
                        ;; в момента на стека има две стойности fibb(n-1) и fibb(n-2)
                        ;; събира резултата на fibb(n-1) и резултата на fibb(n-2)
            i32.add     ;; и понеже това е последната операция това се връщa
        end
    )
    ;; функция, която принтира първите n числа на Фибоначи
    ;; (local $i i32) декларира, че функция има една локална променлива
    (func $nfibb (param $n i32) (local $i i32)
        call $clear ;; изчистваме стария списък от резултати

        local.get $n          ;; бута стойността на $n на стека
        i32.const 1           ;; бута 1 на стека
        i32.ge_s              ;; сравнява 1 и n,ако 1<=$n бута 1, иначе бута 0

        if                    ;; проверява дали върха на стека е различен от 0. 
                              ;; влиза тук, ако 1 <= $n, тоест има поне една итерация

            i32.const 1       ;; бута 1 на стека
            local.set $i      ;; инициализираме $i със стойност 1
                              ;; започва цикъл
            loop $loop        ;; слагаме за да можем по-лесно да работим цикъла

                ;; тялото на цикъла започва от тук
                local.get $i  ;; бута стойността на $i на стека
                              ;; дърпа стойността на $i                         
                call $fibb    ;; и бута стойността на i-то числото на Фибоначи
                call $print   ;; дърпа числото на Фибоначи и го принтира
                ;; тялото на цикъла свършва тук
                ;; еквивалентно на print(fibb(i))

                ;; увличава $i с 1
                local.get $i ;; бута стойността на $i на стека
                i32.const 1  ;; бута 1 на стела
                i32.add      ;; събира ги
                local.set $i ;; дърпа сбора от стека и го запазва в $i

                ;; проверява дали $i <= $n
                local.get $n;; бута стойността на $n на стека
                local.get $i;; бута стойността на $i на стека
                i32.ge_s    ;; сравнява $i и $n и бута 1, ако $i<=$n, иначе бута 0

                br_if $loop ;; продължава цикъла, ако $i <= $n
            end
        end
    )
    (export "nfibb" (func $nfibb));; експортваме функцията fibb за да можем да я викнем от javascript
)