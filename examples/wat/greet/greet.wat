(module
    ;; импортваме функция от js,
    ;; която ще принтира поздрава на DOM-a
    (import "js" "print" (func $print (param i32))) 
    ;; декларираме помощна функция, която да копира данни от едно място
    ;; на друго, подобна функция съществува в C
    ;; тялото е еквивалент на
    ;; for (int i = 0; i < len; i++) {
    ;;      dst[i] = src[i];
    ;; }
    (func $memcpy (param $dst i32) (param $src i32) (param $len i32)
        (local $i i32) (local $byte i32)    ;; декларираме локална променлива $i iи $byte

        i32.const 0           ;; бута 0 на стека
        local.set $i          ;; инициализираме $i със стойност 0

        local.get $len        ;; бута стойността на $len на стека
        local.get $i          ;; бута 0 на стека
        i32.gt_s              ;; сравнява $i и $len, ако $i<$len бута 1, иначе бута 0

        if                    ;; проверява дали върха на стека е различен от 0. 
                              ;; влиза тук, ако $i < $n, тоест има поне една итерация
                              ;; започва цикъл
            loop $loop        ;; слагаме за да можем по-лесно да работим цикъла

                ;; тялото на цикъла започва от тук
                local.get $i  ;; бута стойността на $i на стека
                local.get $src;; бута стойността на $src на стека
                i32.add       ;; събира ги, src+i е адреса на текущия байт в паметта

                              ;; дърпа стойността на src+i от стека 
                i32.load8_u   ;; и бута стойността на текищия байта на стека
                local.set $byte;; запазва в текужия байт в $byte

                local.get $i  ;; бута стойността на $i на стека
                local.get $dst;; бута стойността на $dst на стека
                              ;; събира ги, dst+i е адреса, 
                i32.add       ;; където трябва да запишем текущия байт
                local.get $byte ;; бута стойността на текущия байт на стека
                              ;; дърпа стойнстта на текущия байт от стека
                i32.store8    ;; я записва в паметта на адрес dst+i
                ;; тялото на цикъла свършва тук
                ;; еквивалентно на dst[i] = src[i]

                ;; увличава $i с 1
                local.get $i ;; бута стойността на $i на стека
                i32.const 1  ;; бута 1 на стела
                i32.add      ;; събира ги
                local.set $i ;; дърпа сбора от стека и го запазва в $i

                ;; проверява дали $i < $len
                local.get $len;; бута стойността на $n на стека
                local.get $i;; бута стойността на $i на стека
                i32.gt_s    ;; сравнява $i и $n и бута 1, ако $i<$len, иначе бута 0

                br_if $loop ;; продължава цикъла, ако $i < $len
            end
        end
    )

    ;; деклалираме функция $greet, която получава указател до началото
    ;; на името и дължината името в байтове и връща адреса на
    ;; новия низ в памета. i32 се използва като указател тук
    (func $greet (param $namePtr i32) (param $nameLen i32)
        ;; декларираме една локална променлива, която ще служи като
        ;; указател към резултата
        (local $resultPtr i32)
       
        i32.const 16384     ;; бута 16384 на стека
        local.set $resultPtr;; записва 16384 в локалната променлива

        local.get $resultPtr;; бутаме адреса на резултата на стека
        i32.const 0         ;; 0 е адреса на "Здравей, "
        i32.const 16        ;; 20 е размера на "Здрвей, "
        call $memcpy        ;; копира "Здравей, " в резултата

        local.get $resultPtr;; бутаме адреса на резултата на стека
        i32.const 16        ;; бутаме константата 16 на стека
                            ;; събираме ги, понеже вече "Здравей, " 
                            ;; е записан в резултата, трябва да продължи   
        i32.add             ;; на следващия свободен байт, и именно  $resultPtr + 16
        local.get $namePtr  ;; бута адреса на името на стека
        local.get $nameLen  ;; бута дължината на името на стека
        call $memcpy

        local.get $resultPtr
        call $print
    )
    ;; деклалираме памет с големина 64 килобайта
    ;; разположението в паметта е изцяло по преценка на автора
    ;; низови константи като "Здравей, " ще се съхраняват в адресите [0, 128)
    ;; входен низ (името) ще се съхраняват в адресите [128, 16384)
    ;; резултатен низ (поздрава) ще се съхранява в адресите [16384, 65536)
    (memory $memory 1)
    (data (i32.const 0) "Здравей, ")

    (export "greet" (func $greet))
    (export "memory" (memory $memory))
)
