<!DOCTYPE html>
<html lang="bg">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/style.css" />
    <title>WASM referat</title>
  </head>
  <body>
    <header>
      <h1>WebAssembly - основи, примери</h1>
    </header>
    <aside>
      <nav>
        <ol>
          <li>
            <a href="#what-is-wasm">Какво е WebAssembly</a>
            <ul>
              <li>
                <a href="#design-goals">Какви са целите на WebAssembly</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#core-wasm-concepts">Основни понятия в Wasm</a>
            <ul>
              <li><a href="#bytecode">Bytecode</a></li>
              <li><a href="#stack-machine">Stack machine</a></li>
              <li><a href="#linear-memory">Linear memory</a></li>
              <li><a href="#host">Host</a></li>
            </ul>
          </li>
          <li>
            <a href="#wasm-version-history">История на версиите</a>
            <ul>
              <li><a href="#wasm-1.0">Wasm 1.0 (MVP)</a></li>
              <li><a href="#wasm-2.0">Нововъведения в Wasm 2.0</a></li>
            </ul>
          </li>
        </ol>
      </nav>
    </aside>
    <main>
      <!-- <hr> -->
      <section id="what-is-wasm">
        <h2>Какво е WebAssembly</h2>
        <p>
          WebAssembly (или Wasm) e лесно преносим, безопасен кодов формат от
          ниско ниво създаден за бързо изпълнение и малък размер. Основната му
          цел е да позволи съществуването на високо производителни програми за
          уеб средата, написани на езици различни от JavaScript. Въпреки името
          си, стандартът <b>НЕ</b> разчита на функционалности, които са
          специфични за уеб средата, което му позволява бъде използван в други
          среди.
        </p>
        <br />
        <p>
          На по ниско ниво WebAssembly представлява (virtual instruction set
          architecture) или по-просто казано bytecode. Това позволява да бъде
          интегриран в най-различни среди. Стандартът дефинира
          <strong>множество от инстукции</strong>,
          <strong>двоично кодиране</strong>, <strong>валидиране</strong> и
          <strong>семантика на изпълнението</strong>, както и
          <strong>текстово представяне</strong>.
        </p>

        <br />
        <p>
          WebAssembly е отворен стандарт, който се подържа от
          <a href="https://www.w3.org/community/webassembly/"
            >W3C Community Group</a
          >
        </p>
        <br />
        <article id="design-goals">
          <h3>Какви са целите на WebAssembly</h3>
          <ul>
            <li>
              <b>Бърз</b> - скороста на изпълнение е близка до тази на директно
              изпълняван код (native code)
            </li>
            <li>
              <b>Безопасен</b> - кодът се валидира и изпълнява изолирана среда,
              която предовратява повреда на данните и пробиви в сигурността
            </li>
            <li>Добре дефиниран - форматът е формално дефиниран</li>
            <li>
              <b>Хардуерна независим</b> - може да бъде компилиран на всички
              съвременни архитектури, включително за мобилни устройства и
              вградени системи
            </li>
            <li>
              <b>Езикова независим</b> - не се очаква конкретена програмна
              парадигма или обектен модел
            </li>
            <li>
              <b>Платформена независим</b> - може да върви в броузъра, на
              отделна виртуална машина или интегрирана в други среди
            </li>
            <li>
              <b>Компактен</b> - двоичнят формат е по-малък от типичните
              текстови или директно изпълними формати (native code formats)
            </li>
            <li>
              <b>Модулярен</b> - програмата лесно може да бъде разделена части,
              които могат да бъдат изпратени, кеширани и използвани отделно.
            </li>
            <li>
              <b>Ефективен</b> - декодирането, валидирането и компилацията може
              стане с едно преминаване, независимо дали използваме JIT или AOT
              компилация
            </li>
            <li>
              <b>Поточен</b> - декодирането, валидирането и компилацията могат
              да започнат без да е нужно всички данни да са били заредени
            </li>
            <li>
              <b>Лесен за паралелизиране</b> - декодирането, валидирането и
              компилацията могат да бъдат разделени лесно на независими задачи
            </li>
          </ul>
        </article>
      </section>
      <hr />
      <section id="core-wasm-concepts">
        <h2>Основни понятия в Wasm</h2>
        <p>
          WebAssembly е двоично представяне на език от ниско ниво, който прилича
          на assembly. Което с други думи означава, че Wasm е bytecode, но какво
          е bytecode.
        </p>
        <br />
        <article id="bytecode">
          <h3>Bytecode</h3>
          <p>
            Bytecode е междинно представяне под формата на множество инструкции.
            Той се намира между човешко-читаемия код и машинния код.
            Най-известният пример за bytecode е Java bytecode. Компилаторът на
            Java валидира програмата, проверява типовете и генерира bytecode-а.
            След това той се подава на JVM (Java Virtual Machine), който го
            компилира до машинен код и го изпълнява. Това позволява на
            програмистите да пишат код, който е независим от компютърната
            архитектура, операционната система и средата за изпълнение.
          </p>
          <img
            src="images/java_bytecode_diagram.webp"
            alt="java bytecode diagram"
          />
        </article>
        <br />
        <p>
          Докато Java bytecode се абстрахира от компютърната архитектура и
          операционната система чрез JVM, Wasm бута идеята за bytecode една
          стъпка по-напред, като се абстрахира от и платформата чрез инструкции
          на по-ниско ниво. Това позволява на различни езици за програмиране да
          компилират код за Wasm, без да са обвързани с ограниченията на
          конкретна среда като JVM, която изисква езикът да бъде
          обектно-ориентиран или да поддържа garbage collection.
        </p>
        <br />
        <p>
          В следващата секция ще разгледаме част от инструкциите в Wasm, но
          преди това важно да се отбележи, че изчислителният модел на
          WebAssembly e <strong>stack machine</strong>, но какво е stack
          machine.
        </p>
        <br />
        <article id="stack-machine">
          <h3>Stack machine</h3>
          <p>
            Stack machine е изчислителен модел, при който инструкциите, вместо
            да използват регистри, използват стека, за да съхраняват аргументи
            (вземат ги от върха на стека) и да записват резултата обратно на
            стека (бутат го на върха на стека). Този подход е предпочитан от
            много виртуални машини поради следните предимства:
          </p>
          <ul>
            <li>
              <b>По-компактни инструкции</b> - инструкциите в stack machine не
              съдържат адреси на регистри
            </li>
            <li>
              <b>Лесно генериране код от езици от по-високо ниво</b> - Повечето
              езици за програмиране използват локални променливи и изрази, които
              естествено се съхраняват върху стек.
            </li>
            <li>
              <b>Хардуернa независимост</b> - не е нужно да съобразява с
              регистровата организация на процесора.
            </li>
            <li>
              <b>По-лесна валидация на кода</b> - улеснява се проверката за
              типове
            </li>
          </ul>
          <img
            src="images/stack_machine_add_example.webp"
            alt="stack machine add example"
          />
        </article>
        <br />
        <p>
          Повечето програми имат нужда от нещо повече от стак за да съхраняват
          обекти, чиито размер не е известен по-време на компилация. Тук идва
          темата за организация на памет. Wasm изпозва linear memory модел за
          организация на паметта.
        </p>
        <br />
        <article id="linear-memory">
          <h3>Linear memory</h3>
          <p>
            Linear memory e продължителен, изменяем (mutable) масив от байтове.
            Тази памет първоначно бива създадена с отпределен размер, но може да
            расте динамично. Програма може да зарежда и съхранява стойности
            от/на linear memory на произволен байтов адрес (включително на
            неподравнен). Този модел има много предимства, но и недостатъци:
          </p>
          <h4>Предимства</h4>
          <ul>
            <li>
              <b>Лесен за имплементация</b> - Лесно се имплементира в броузър и
              други среди, както и улеснява работата на компилаторите.
            </li>
            <li>
              <b>Лесно преносим</b> - една и съща структура за всеки процесор за
              разлика от paged memory
            </li>
            <li>
              <b>Бърз</b> - адресите се смятат директно, докато във paged memory
              виртуалните адреси трябва да се преведат до реалните.
            </li>
            <li>
              <b>Подходящ за системни езици</b> - въпреки, че една от целите
              Wasm e да е независим от език за програмине, linear memory моделът
              работи много добре със системни езици като Rust, C и C++
            </li>
          </ul>
          <h4>Недостатъци</h4>
          <ul>
            <li>
              <b>Затруднена подръжка на Garbage Collector</b> - моделът не
              предоставя необходимата информация, на която повечето Garbage
              Collector-и разчитат. За да решат този проблем беше разработено
              разширение към WebAssembly стандарта - наречен WasmGC, което не
              използва linear memory
            </li>
            <li>
              <b>Задрунено многонишково програмиране</b> - нишките в Wasm имат
              от нуждаят от SharedArrayBuffer, което е изключено по подразбиране
              в модерните броузъри.
            </li>
          </ul>
        </article>
        <br />
        <article id="host">
          <h3>Host</h3>
          <p>
            Обикновено WebAssembly имплементация ще бъде вградена в host срада,
            което ще определя как различните модули ще бъдат зареждани, как
            импортите ще бъдат предоставени, включително дениции от host-a и как
            експортите ще бъдат достъпвани.
          </p>
        </article>
      </section>
      <hr />
      <section id="wasm-version-history">
        <h2>История на версиите</h2>
        <br />
        <article id="wasm-1.0">
          <h3>Wasm 1.0 (MVP)</h3>
          <p>
            Преди да разгледаме какво е било добавено в следващите версии на
            Wasm, трябва да разгледаме как е излглеждало WebAssembly в първата
            си версия (известна още като MVP). Тук ще опишем структурата на една
            Wasm програма,докато в следващата секция ще разгледаме конкретни
            примери. MVP-то описва WebAssembly като bytecode за стакова машина,
            която използва linear memory с 32-битови адреси.
          </p>
          <br />
          <h4>Module</h4>
          <p>
            Всяка Wasm програма се състои от независим <strong>модули</strong>.
            Модулът е основната единица за разпостранение в света на
            WebAssembly. Всеки модул може да съдържа <b>секция</b> за
            <strong>типове на функции</strong>, <strong>функции</strong>,
            <strong>таблици</strong>, <strong>глобални променливи</strong>,
            <strong>памети</strong>, <strong>импортове</strong> и
            <strong>експортове</strong>
          </p>
          <br />
          <h4>Types</h4>
          <p>
            В MVP e имало 4 типа данни <strong>i32</strong>,
            <strong>i64</strong>, <strong>f32</strong> и <strong>f64</strong>.
            i32 и i64 представляват съответно 32-битово и 64-битово цяло число
            (interger - от там i32 - integer 32 bits). f32 и f64 представляват
            съответно 32-битово и 64-битово число с плаваща запетая описани в
            <a href="https://ieeexplore.ieee.org/document/8766229">IEEE 754</a>.
            i32 се използва като ykaзател понеже Wasm 1.0 има 32-битово адресно
            постанство.
          </p>
          <br />
          <h4>Functions</h4>
          <p>
            За всяка фунция в WebAssembly трябва се укажат типа параметрите и
            типа на резултите. Докато в първата версия се позволява да се връща
            само една стойност, това се променя в следващите версиии. Типовете
            на глобалните променливи също трябва се укажат както и дали
            глобалната променлива може да се променя или не (mut or const).
          </p>
          <br />
          <h4>Tables</h4>
          <p>
            Таблиците в Wasm MVP-то са представлявали масиви от скрити
            референции (opaque references - референция към обект, чиято вътрешна
            структура не е достъпна, не е видима или не може да бъде
            манипулирана директно.). Само един такъв тип е съществувал и това е
            funcref (референция към фунция). Таблиците позволяват съществуването
            на <b>указатели към функции (function pointers)</b>, <b>vtables</b>,
            <b>динамично избиране на метод (dynamic dispaching)</b> и други.
          </p>
          <br />
          <h4>Memory</h4>
          <p>
            В горната секция обеснихме какво е linear memory. Важно е да се
            спомене е, че когато в Wasm се каже, че памет има размер 1 се има
            предвид 64 килобайта. Паметта може да расте само с отрязъци кратни
            на 64 килобайта
          </p>
          <br />
          <h4>Imports and exports</h4>
          <p>
            Импортовете и експортовете позволяват WebAssembly да обменя данни с
            host средата. Импортовете позволяват на Wasm да използва функции и
            данни предоставени от host средата , докато експортовете позволяват
            host средата да вика функции деклалирани в Wasm. Пример за импорт би
            било функция, която дава достъп на WebAssembly да DOM-а, докато
            пример за експорт би бил някой алгоритъм, който е написан на Wasm с
            цел бързо изпълнение като звукова или видео обработка
          </p>
        </article>
        <br />
        <article id="wasm-2.0">
          <h3>Нововъведения в Wasm 2.0</h3>
          <h4>SIMD</h4>
          <p>
            Основното въведение в Wasm 2.0 е типа <strong>v128</strong>, който
            има големина 128-бита и позволява
            <strong>SIMD операции (Single Instruction, Multiple Data)</strong>.
            С този тип са добабавени повече от 60 нови инструкции, които
            представляват различни SIMD операции. В този реферат няма да се
            обърне голямо внимание на тях.
          </p>
          <br />
          <h4>Други въведения в Wasm 2.0</h4>
          <p>
            Други по-малки въведения позволяват на функциите и блоковете да
            връщат няколко стойности, дефинирането на няколко таблици и други.
          </p>
        </article>
        <br />
        <article id="wasm-3.0">
          <h3>Нововъведения в Wasm 3.0</h3>
          <h4>Garbage Collection</h4>
          <p>
            Най-голямото въведение в Wasm 3.0 въведението на
            <strong>Garbage Collection</strong>. Предлага алтернативен модел на
            памет от linear-memory и използва <strong>WasmGC</strong>. Въвежда
            няколко нови референтни типове за позволи на компилаторите да
            генерират код, който изпозва WasmGC. В този реферат няма обърне
            голямо внимание на Garbage Collector-a понеже, кодът който излиза от
            компилатора е тежък за четене и излиза от основите.
          </p>
          <br />
          <h4>64-битово адресно пространсто</h4>
          <p>
            Вече за указатели може да използва i64, което вдига възможната
            памет, която един модул може да алокира от 4 гигабайта, до
            теоретично 16 exabytes (16,777,216 терабайта)
          </p>
          <h4>Exception Handling</h4>
          <p>
            Wasm 3.0 предоставя механизми за работата с изключения, което беше
            едиственото нещо от C++, което не може да се представи в
            WebAssembly. Хакове съществуваха, които заобикаляха този проблем, но
            вече това не е нужно. Това се постига чрез добавянето на нова секция
            за <strong>tags</strong> в модул, която описва типовете изключения.
            Освен новата секция бяха добавени и няколко инструкции за работа с
            изключения
          </p>
          <h4>Multiple Memories</h4>
          <p>
            От Wasm 3.0 нататък е модул може да дефинира няколко памети, които
            да растат независимо една от друга
          </p>
          <h4>Tail Calls</h4>
          <p>
            Друго малко въведение, което беше добавено, което е ключово за много
            функционалнални езици
          </p>
        </article>
        <br />
        <article>
          <h3>Бъдещи въведения</h3>
          <p>
            Авторите споменаха, че две възможни въведения са нишки (threads) и
            stack-switching, което ще позволи неща като coroutines и green
            threads. Ако тези неща бъдат изпълнени можем да видим езици като
            java и c# да се компилаторат до WebAssembly.
          </p>
        </article>
      </section>
      <hr>
    </main>
    <footer>footer here</footer>
  </body>
</html>
