<!DOCTYPE html>
<html lang="bg">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/style.css" />
    <title>WASM referat</title>
  </head>
  <body>
    <header>
      <h1>WebAssembly - основи, примери</h1>
    </header>
    <aside>
      <nav>
        <ol>
          <li><a href="#what-is-wasm">Какво е WebAssembly</a></li>
          <li><a href="#core-wasm-concepts">Основни понятия в Wasm</a></li>
          <li><a href="#wasm-version-history">Кратка история на версиите</a></li>
        </ol>
      </nav>
    </aside>
    <main>
      <!-- <hr> -->
      <section id="what-is-wasm">
        <h2>Какво е WebAssembly</h2>
        <p>
          WebAssembly (или Wasm) e лесно преносим, безопасен кодов формат от
          ниско ниво създаден за бързо изпълнение и малък размер. Основната му
          цел е да позволи съществуването на високо производителни програми за
          уеб средата, написани на езици различни от JavaScript. Въпреки името
          си, стандартът <b>НЕ</b> разчита на функционалности, които са
          специфични за уеб средата, което му позволява бъде използван в други
          среди.
        </p>
        <br />
        <p>
          На по ниско ниво WebAssembly представлява (virtual instruction set
          architecture) или по-просто казано bytecode. Това позволява да бъде
          интегриран в най-различни среди. Стандартът дефинира
          <strong>множество от инстукции</strong>,
          <strong>двоично кодиране</strong>, <strong>валидиране</strong> и
          <strong>семантика на изпълнението</strong>, както и
          <strong>текстово представяне</strong>.
        </p>

        <br />
        <p>
          WebAssembly е отворен стандарт, който се подържа от
          <a href="https://www.w3.org/community/webassembly/"
            >W3C Community Group</a
          >
        </p>
        <br />
        <article>
          <h3>Какви са целите на WebAssembly</h3>
          <ul>
            <li>
              <b>Бърз</b> - скороста на изпълнение е близка до тази на директно
              изпълняван код (native code)
            </li>
            <li>
              <b>Безопасен</b> - кодът се валидира и изпълнява изолирана среда,
              която предовратява повреда на данните и пробиви в сигурността
            </li>
            <li>Добре дефиниран - форматът е формално дефиниран</li>
            <li>
              <b>Хардуерна независим</b> - може да бъде компилиран на всички
              съвременни архитектури, включително за мобилни устройства и
              вградени системи
            </li>
            <li>
              <b>Езикова независим</b> - не се очаква конкретена програмна
              парадигма или обектен модел
            </li>
            <li>
              <b>Платформена независим</b> - може да върви в броузъра, на
              отделна виртуална машина или интегрирана в други среди
            </li>
            <li>
              <b>Компактен</b> - двоичнят формат е по-малък от типичните
              текстови или директно изпълними формати (native code formats)
            </li>
            <li>
              <b>Модулярен</b> - програмата лесно може да бъде разделена части,
              които могат да бъдат изпратени, кеширани и използвани отделно.
            </li>
            <li>
              <b>Ефективен</b> - декодирането, валидирането и компилацията може
              стане с едно преминаване, независимо дали използваме JIT или AOT
              компилация
            </li>
            <li>
              <b>Поточен</b> - декодирането, валидирането и компилацията могат
              да започнат без да е нужно всички данни да са били заредени
            </li>
            <li>
              <b>Лесен за паралелизиране</b> - декодирането, валидирането и
              компилацията могат да бъдат разделени лесно на независими задачи
            </li>
          </ul>
        </article>
      </section>
      <hr />
      <section id="core-wasm-concepts">
        <h2>Основни понятия в Wasm</h2>
        <p>
          WebAssembly е двоично представяне на език от ниско ниво, който прилича
          на assembly. Което с други думи означава, че Wasm е bytecode, но какво
          е bytecode.
        </p>
        <br />
        <article>
          <h3>Bytecode</h3>
          <p>
            Bytecode е междинно представяне под формата на множество инструкции.
            Той се намира между човешко-читаемия код и машинния код.
            Най-известният пример за bytecode е Java bytecode. Компилаторът на
            Java валидира програмата, проверява типовете и генерира bytecode-а.
            След това той се подава на JVM (Java Virtual Machine), който го
            компилира до машинен код и го изпълнява. Това позволява на
            програмистите да пишат код, който е независим от компютърната
            архитектура, операционната система и средата за изпълнение.
          </p>
          <img
            src="images/java_bytecode_diagram.webp"
            alt="java bytecode diagram"
          />
        </article>
        <br />
        <p>
          Докато Java bytecode се абстрахира от компютърната архитектура и
          операционната система чрез JVM, Wasm бута идеята за bytecode една
          стъпка по-напред, като се абстрахира от и платформата чрез инструкции
          на по-ниско ниво. Това позволява на различни езици за програмиране да
          компилират код за Wasm, без да са обвързани с ограниченията на
          конкретна среда като JVM, която изисква езикът да бъде
          обектно-ориентиран или да поддържа garbage collection.
        </p>
        <br />
        <p>
          В следващата секция ще разгледаме част от инструкциите в Wasm, но
          преди това важно да се отбележи, че изчислителният модел на
          WebAssembly e <strong>stack machine</strong>, но какво е stack
          machine.
        </p>
        <br />
        <article>
          <h3>Stack machine</h3>
          <p>
            Stack machine е изчислителен модел, при който инструкциите, вместо
            да използват регистри, използват стека, за да съхраняват аргументи
            (вземат ги от върха на стека) и да записват резултата обратно на
            стека (бутат го на върха на стека). Този подход е предпочитан от
            много виртуални машини поради следните предимства:
          </p>
          <ul>
            <li>
              <b>По-компактни инструкции</b> - инструкциите в stack machine не
              съдържат адреси на регистри
            </li>
            <li>
              <b>Лесно генериране код от езици от по-високо ниво</b> - Повечето
              езици за програмиране използват локални променливи и изрази, които
              естествено се съхраняват върху стек.
            </li>
            <li>
              <b>Хардуернa независимост</b> - не е нужно да съобразява с
              регистровата организация на процесора.
            </li>
            <li>
              <b>По-лесна валидация на кода</b> - улеснява се проверката за
              типове
            </li>
          </ul>
          <img
            src="images/stack_machine_add_example.webp"
            alt="stack machine add example"
          />
        </article>
        <br />
        <p>
          Повечето програми имат нужда от нещо повече от стак за да съхраняват
          обекти, чиито размер не е известен по-време на компилация. Тук идва
          темата за организация на памет. Wasm изпозва linear memory модел за
          организация на паметта.
        </p>
        <br />
        <article>
          <h3>Linear memory</h3>
          <p>
            Linear memory e продължителен, изменяем (mutable) масив от байтове.
            Тази памет първоначно бива създадена с отпределен размер, но може да
            расте динамично. Програма може да зарежда и съхранява стойности
            от/на linear memory на произволен байтов адрес (включително на
            неподравнен). Този модел има много предимства, но и недостатъци:
          </p>
          <h4>Предимства</h4>
          <ul>
            <li>
              <b>Лесен за имплементация</b> - Лесно се имплементира в броузър и
              други среди, както и улеснява работата на компилаторите.
            </li>
            <li>
              <b>Лесно преносим</b> - една и съща структура за всеки процесор за
              разлика от paged memory
            </li>
            <li>
              <b>Бърз</b> - адресите се смятат директно, докато във paged memory
              виртуалните адреси трябва да се преведат до реалните.
            </li>
            <li>
              <b>Подходящ за системни езици</b> - въпреки, че една от целите Wasm e да
              е независим от език за програмине, linear memory моделът работи
              много добре със системни езици като Rust, C и C++
            </li>
          </ul>
          <h4>Недостатъци</h4>
          <ul>
            <li>
              <b>Затруднена подръжка на Garbage Collector</b> - моделът не предоставя
              необходимата информация, на която повечето Garbage Collector-и
              разчитат. За да решат този проблем беше разработено разширение към
              WebAssembly стандарта - наречен WasmGC, което не използва linear
              memory
            </li>
            <li>
              <b>Задрунено многонишково програмиране</b> - нишките в Wasm имат от
              нуждаят от SharedArrayBuffer, което е изключено по подразбиране в
              модерните броузъри.
            </li>
          </ul>
        </article>
        <br />
        <p>
          Обикновено WebAssembly имплементация ще бъде вградена в host срада,
          което ще определя как различните модули ще бъдат зареждани, как
          импортите ще бъдат предоставени, включително дениции от host-a и как
          експортите ще бъдат достъпвани.
        </p>
      </section>
      <hr />
      <section id="wasm-version-history">
        <h2>Кратка история на версиите</h2>
        <br />
        <article>
          <h3>Wasm 1</h3>
        </article>
        <article>
          <h3>Wasm 2</h3>
        </article>
        <article>
          <h3>Wasm 3</h3>
        </article>
      </section>
    </main>
    <footer>
      footer here
    </footer>
  </body>
</html>
