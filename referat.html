<!DOCTYPE html>
<html lang="bg">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/highlight/atom-one-dark.min.css" />
    <script type="module" src="js/script.js" defer></script>
    <title>WASM referat</title>
  </head>
  <body>
    <header>
      <h1>WebAssembly - основи, примери</h1>
    </header>
    <aside>
      <nav>
        <ol>
          <li>
            <a href="#what-is-wasm">Какво е WebAssembly</a>
            <ul>
              <li>
                <a href="#design-goals">Какви са целите на WebAssembly</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#core-wasm-concepts">Основни понятия в Wasm</a>
            <ul>
              <li><a href="#bytecode">Bytecode</a></li>
              <li><a href="#stack-machine">Stack machine</a></li>
              <li><a href="#linear-memory">Linear memory</a></li>
              <li><a href="#host">Host</a></li>
            </ul>
          </li>
          <li>
            <a href="#wasm-version-history">История на версиите</a>
            <ul>
              <li><a href="#wasm-1.0">Wasm 1.0 (MVP)</a></li>
              <li><a href="#wasm-2.0">Нововъведения в Wasm 2.0</a></li>
              <li><a href="#wasm-3.0">Нововъведения в Wasm 3.0</a></li>
            </ul>
          </li>
          <li>
            <a href="#wat">WAT</a>
          </li>
          <li>
            <a href="#wasm-as-compilation-target">
              WebAssembly като цел за компилация
            </a>
          </li>
        </ol>
      </nav>
    </aside>
    <main>
      <!-- <hr> -->
      <section id="what-is-wasm">
        <h2>Какво е WebAssembly</h2>
        <p>
          WebAssembly (или Wasm) e лесно преносим, безопасен кодов формат от
          ниско ниво създаден за бързо изпълнение и малък размер. Основната му
          цел е да позволи съществуването на високо производителни програми за
          уеб средата, написани на езици различни от JavaScript. Въпреки името
          си, стандартът <b>НЕ</b> разчита на функционалности, които са
          специфични за уеб средата, което му позволява бъде използван в други
          среди.
        </p>
        <br />
        <p>
          На по ниско ниво WebAssembly представлява (virtual instruction set
          architecture) или по-просто казано bytecode. Това позволява да бъде
          интегриран в най-различни среди. Стандартът дефинира
          <strong>множество от инстукции</strong>,
          <strong>двоично кодиране</strong>, <strong>валидиране</strong> и
          <strong>семантика на изпълнението</strong>, както и
          <strong>текстово представяне</strong>.
        </p>

        <br />
        <p>
          WebAssembly е отворен стандарт, който се подържа от
          <a href="https://www.w3.org/community/webassembly/"
            >W3C Community Group</a
          >
        </p>
        <br />
        <article id="design-goals">
          <h3>Какви са целите на WebAssembly</h3>
          <ul>
            <li>
              <b>Бърз</b> - скороста на изпълнение е близка до тази на директно
              изпълняван код (native code)
            </li>
            <li>
              <b>Безопасен</b> - кодът се валидира и изпълнява изолирана среда,
              която предовратява повреда на данните и пробиви в сигурността
            </li>
            <li>Добре дефиниран - форматът е формално дефиниран</li>
            <li>
              <b>Хардуерна независим</b> - може да бъде компилиран на всички
              съвременни архитектури, включително за мобилни устройства и
              вградени системи
            </li>
            <li>
              <b>Езикова независим</b> - не се очаква конкретена програмна
              парадигма или обектен модел
            </li>
            <li>
              <b>Платформена независим</b> - може да върви в броузъра, на
              отделна виртуална машина или интегрирана в други среди
            </li>
            <li>
              <b>Компактен</b> - двоичнят формат е по-малък от типичните
              текстови или директно изпълними формати (native code formats)
            </li>
            <li>
              <b>Модулярен</b> - програмата лесно може да бъде разделена части,
              които могат да бъдат изпратени, кеширани и използвани отделно.
            </li>
            <li>
              <b>Ефективен</b> - декодирането, валидирането и компилацията може
              стане с едно преминаване, независимо дали използваме JIT или AOT
              компилация
            </li>
            <li>
              <b>Поточен</b> - декодирането, валидирането и компилацията могат
              да започнат без да е нужно всички данни да са били заредени
            </li>
            <li>
              <b>Лесен за паралелизиране</b> - декодирането, валидирането и
              компилацията могат да бъдат разделени лесно на независими задачи
            </li>
          </ul>
        </article>
      </section>
      <hr />
      <section id="core-wasm-concepts">
        <h2>Основни понятия в Wasm</h2>
        <p>
          WebAssembly е двоично представяне на език от ниско ниво, който прилича
          на assembly. Което с други думи означава, че Wasm е bytecode, но какво
          е bytecode.
        </p>
        <br />
        <article id="bytecode">
          <h3>Bytecode</h3>
          <p>
            Bytecode е междинно представяне под формата на множество инструкции.
            Той се намира между човешко-читаемия код и машинния код.
            Най-известният пример за bytecode е Java bytecode. Компилаторът на
            Java валидира програмата, проверява типовете и генерира bytecode-а.
            След това той се подава на JVM (Java Virtual Machine), който го
            компилира до машинен код и го изпълнява. Това позволява на
            програмистите да пишат код, който е независим от компютърната
            архитектура, операционната система и средата за изпълнение.
          </p>

          <figure id="diagram-1">
            <img
              src="images/java_bytecode_diagram.webp"
              alt="java bytecode diagram"
            />
            <figcaption>
              Диаграма 1 - компилация и изпълнение на Java bytecode
            </figcaption>
          </figure>
        </article>
        <br />
        <p>
          Докато Java bytecode се абстрахира от компютърната архитектура и
          операционната система чрез JVM, Wasm бута идеята за bytecode една
          стъпка по-напред, като се абстрахира от и платформата чрез инструкции
          на по-ниско ниво. Това позволява на различни езици за програмиране да
          компилират код за Wasm, без да са обвързани с ограниченията на
          конкретна среда като JVM, която изисква езикът да бъде
          обектно-ориентиран или да поддържа garbage collection.
        </p>
        <br />
        <p>
          В <a href="#wat">секция WAT</a> ще разгледаме част от инструкциите в
          Wasm, но преди това важно да се отбележи, че изчислителният модел на
          WebAssembly e <strong>stack machine</strong>, но какво е stack
          machine.
        </p>
        <br />
        <article id="stack-machine">
          <h3>Stack machine</h3>
          <p>
            Stack machine е изчислителен модел, при който инструкциите, вместо
            да използват регистри, използват стека, за да съхраняват аргументи
            (дърпа ги от върха на стека) и да записват резултата обратно на
            стека (бутат го на върха на стека). Този подход е предпочитан от
            много виртуални машини поради следните предимства:
          </p>
          <ul>
            <li>
              <b>По-компактни инструкции</b> - инструкциите в stack machine не
              съдържат адреси на регистри
            </li>
            <li>
              <b>Лесно генериране код от езици от по-високо ниво</b> - Повечето
              езици за програмиране използват локални променливи и изрази, които
              естествено се съхраняват върху стек.
            </li>
            <li>
              <b>Хардуернa независимост</b> - не е нужно да съобразява с
              регистровата организация на процесора.
            </li>
            <li>
              <b>По-лесна валидация на кода</b> - улеснява се проверката за
              типове
            </li>
          </ul>
          <figure id="diagram-2">
            <img
              src="images/stack_machine_add_example.webp"
              alt="stack machine add example"
            />
            <figcaption>
              Диаграма 2 - събиране на 2 числа в стекова машина
            </figcaption>
          </figure>
        </article>
        <br />
        <p>
          Повечето програми имат нужда от нещо повече от стек за да съхраняват
          обекти, чиито размер не е известен по-време на компилация. Тук идва
          темата за организация на памет. Wasm изпозва linear memory модел за
          организация на паметта.
        </p>
        <br />
        <article id="linear-memory">
          <h3>Linear memory</h3>
          <p>
            Linear memory e продължителен, изменяем (mutable) масив от байтове.
            Тази памет първоначно бива създадена с отпределен размер, но може да
            расте динамично. Програма може да зарежда и съхранява стойности
            от/на linear memory на произволен байтов адрес (включително на
            неподравнен). Този модел има много предимства, но и недостатъци:
          </p>
          <h4>Предимства</h4>
          <ul>
            <li>
              <b>Лесен за имплементация</b> - Лесно се имплементира в броузър и
              други среди, както и улеснява работата на компилаторите.
            </li>
            <li>
              <b>Лесно преносим</b> - една и съща структура за всеки процесор за
              разлика от paged memory
            </li>
            <li>
              <b>Бърз</b> - адресите се смятат директно, докато във paged memory
              виртуалните адреси трябва да се преведат до реалните.
            </li>
            <li>
              <b>Подходящ за системни езици</b> - въпреки, че една от целите
              Wasm e да е независим от език за програмине, linear memory моделът
              работи много добре със системни езици като Rust, C и C++
            </li>
          </ul>
          <h4>Недостатъци</h4>
          <ul>
            <li>
              <b>Затруднена подръжка на Garbage Collector</b> - моделът не
              предоставя необходимата информация, на която повечето Garbage
              Collector-и разчитат. За да решат този проблем беше разработено
              разширение към WebAssembly стандарта - наречен WasmGC, което не
              използва linear memory
            </li>
            <li>
              <b>Задрунено многонишково програмиране</b> - нишките в Wasm имат
              от нуждаят от SharedArrayBuffer, което е изключено по подразбиране
              в модерните броузъри.
            </li>
          </ul>
        </article>
        <br />
        <article id="host">
          <h3>Host</h3>
          <p>
            Обикновено WebAssembly имплементация ще бъде вградена в host срада,
            което ще определя как различните модули ще бъдат зареждани, как
            импортите ще бъдат предоставени, включително дениции от host-a и как
            експортите ще бъдат достъпвани.
          </p>
        </article>
      </section>
      <hr />
      <section id="wasm-version-history">
        <h2>История на версиите</h2>
        <br />
        <article id="wasm-1.0">
          <h3>Wasm 1.0 (MVP)</h3>
          <p>
            Преди да разгледаме какво е било добавено в следващите версии на
            Wasm, трябва да разгледаме как е излглеждало WebAssembly в първата
            си версия (известна още като MVP). Тук ще опишем структурата на една
            Wasm програма,докато в следващата <a href="#wat">секция WAT</a> ще
            разгледаме конкретни примери. MVP-то описва WebAssembly като
            bytecode за стекова машина, която използва linear memory с 32-битови
            адреси.
          </p>
          <br />
          <h4>Module</h4>
          <p>
            Всяка Wasm програма се състои от независим <strong>модули</strong>.
            Модулът е основната единица за разпостранение в света на
            WebAssembly. Всеки модул може да съдържа <b>секция</b> за
            <strong>типове на функции</strong>, <strong>функции</strong>,
            <strong>таблици</strong>, <strong>глобални променливи</strong>,
            <strong>памети</strong>, <strong>импортове</strong> и
            <strong>експортове</strong>
          </p>
          <br />
          <h4>Types</h4>
          <p>
            В MVP e имало 4 типа данни <strong>i32</strong>,
            <strong>i64</strong>, <strong>f32</strong> и <strong>f64</strong>.
            i32 и i64 представляват съответно 32-битово и 64-битово цяло число
            (interger - от там i32 - integer 32 bits). f32 и f64 представляват
            съответно 32-битово и 64-битово число с плаваща запетая описани в
            <a href="https://ieeexplore.ieee.org/document/8766229">IEEE 754</a>.
            i32 се използва като ykaзател понеже Wasm 1.0 има 32-битово адресно
            постанство.
          </p>
          <br />
          <h4>Functions</h4>
          <p>
            За всяка функция в WebAssembly трябва се укажат типа параметрите и
            типа на резултите. Докато в първата версия се позволява да се връща
            само една стойност, това се променя в следващите версиии. Типовете
            на глобалните променливи също трябва се укажат както и дали
            глобалната променлива може да се променя или не (mut or const).
          </p>
          <br />
          <h4>Tables</h4>
          <p>
            Таблиците в Wasm MVP-то са представлявали масиви от скрити
            референции (opaque references - референция към обект, чиято вътрешна
            структура не е достъпна, не е видима или не може да бъде
            манипулирана директно.). Само един такъв тип е съществувал и това е
            funcref (референция към функция). Таблиците позволяват
            съществуването на <b>указатели към функции (function pointers)</b>,
            <b>vtables</b>,
            <b>динамично избиране на метод (dynamic dispaching)</b> и други.
          </p>
          <br />
          <h4>Memory</h4>
          <p>
            В горната секция
            <a href="#linear-memory">Linear memory</a> обеснихме какво е linear
            memory. Важно е да се спомене е, че когато в Wasm се каже, че памет
            има размер 1 се има предвид 64 килобайта. Паметта може да расте само
            с отрязъци кратни на 64 килобайта
          </p>
          <br />
          <h4>Imports and exports</h4>
          <p>
            Импортовете и експортовете позволяват WebAssembly да обменя данни с
            host средата. Импортовете позволяват на Wasm да използва функции и
            данни предоставени от host средата , докато експортовете позволяват
            host средата да вика функции декларирани в Wasm. Пример за импорт би
            било функция, която дава достъп на WebAssembly да DOM-а, докато
            пример за експорт би бил някой алгоритъм, който е написан на Wasm с
            цел бързо изпълнение като звукова или видео обработка
          </p>
        </article>
        <br />
        <article id="wasm-2.0">
          <h3>Нововъведения в Wasm 2.0</h3>
          <h4>SIMD</h4>
          <p>
            Основното въведение в Wasm 2.0 е типа <strong>v128</strong>, който
            има големина 128-бита и позволява
            <strong>SIMD операции (Single Instruction, Multiple Data)</strong>.
            С този тип са добабавени повече от 60 нови инструкции, които
            представляват различни SIMD операции. В този реферат няма да се
            обърне голямо внимание на тях.
          </p>
          <br />
          <h4>Други въведения в Wasm 2.0</h4>
          <p>
            Други по-малки въведения позволяват на функциите и блоковете да
            връщат няколко стойности, дефинирането на няколко таблици и други.
          </p>
        </article>
        <br />
        <article id="wasm-3.0">
          <h3>Нововъведения в Wasm 3.0</h3>
          <h4>Garbage Collection</h4>
          <p>
            Най-голямото въведение в Wasm 3.0 въведението на
            <strong>Garbage Collection</strong>. Предлага алтернативен модел на
            памет от linear-memory и използва <strong>WasmGC</strong>. Въвежда
            няколко нови референтни типове за позволи на компилаторите да
            генерират код, който изпозва WasmGC. В този реферат няма обърне
            голямо внимание на Garbage Collector-a понеже, кодът който излиза от
            компилатора е тежък за четене и излиза от основите.
          </p>
          <br />
          <h4>64-битово адресно пространсто</h4>
          <p>
            Вече за указатели може да използва i64, което вдига възможната
            памет, която един модул може да алокира от 4 гигабайта, до
            теоретично 16 exabytes (16,777,216 терабайта)
          </p>
          <br />
          <h4>Exception Handling</h4>
          <p>
            Wasm 3.0 предоставя механизми за работата с изключения, което беше
            едиственото нещо от C++, което не може да се представи в
            WebAssembly. Хакове съществуваха, които заобикаляха този проблем, но
            вече това не е нужно. Това се постига чрез добавянето на нова секция
            за <strong>tags</strong> в модул, която описва типовете изключения.
            Освен новата секция бяха добавени и няколко инструкции за работа с
            изключения
          </p>
          <br />
          <h4>Multiple Memories</h4>
          <p>
            От Wasm 3.0 нататък е модул може да дефинира няколко памети, които
            да растат независимо една от друга
          </p>
          <h4>Tail Calls</h4>
          <p>
            Друго малко въведение, което беше добавено, което е ключово за много
            функционалнални езици
          </p>
        </article>
        <br />
        <article>
          <h3>Бъдещи въведения</h3>
          <p>
            Авторите споменаха, че две възможни въведения са нишки (threads) и
            stack-switching, което ще позволи неща като coroutines и green
            threads. Ако тези неща бъдат изпълнени можем да видим езици като
            java и c# да се компилаторат до WebAssembly.
          </p>
        </article>
      </section>
      <hr />
      <section id="wat">
        <h2>WAT</h2>
        <p>
          Преди да продължим с примерите, трябва да разгледаме синтаксиса на
          Wasm, но той е двоичен двоичен формат и не предназначен да бъде четен
          от хора. За щастие създателите на WebAssembly са помислили за това.
          WAT (WebAssembly Text) е текстова репрезентация на Wasm.
        </p>
        <br />
        <p>
          Синтаксисът на WAT наподобява Lisp (Scheme е диалект на Lisp).
          Възмойно най-простата програма на WAT е:
        </p>
        <figure id="code-snippet-1">
          <pre><code>(module)</code></pre>
          <figcaption>Код снипет 1 - най-простият WAT модул</figcaption>
        </figure>
        <p>
          <a href="#code-snippet-1">Код снипет 1</a> декларира празен модул. В
          секция <a href="#wasm-1.0">Wasm 1.0 - (MVP)</a> разгледахме съставните
          части на един модул. Нека сега видим как изглежда един модул с
          единствена функция, която събира аргументи си.
        </p>
        <figure id="code-snippet-2">
          <pre><code>(module
  (func $add (param $a i32) (param $b i32) (result i32)
    local.get $a  ;; $a е 32-битово цяло число и го бутаме на стека
    local.get $b  ;; същото се отнася за $b
                  ;; тази инстукция дърпа двете най-горни стойности 
                  ;; и ги събира като бута резултата на върха на стека
                  ;; функцията "връща" сбора, понеже той е най-горния 
     i32.add      ;; елемент на стека
))</code></pre>
          <figcaption>
            Код снипет 2 - WAT модул с функция за събиране
          </figcaption>
        </figure>
        <p>
          На <a href="#diagram-2">диаграма 2</a> e показанa функцията от
          <a href="#code-snippet-2">код снипет 2</a>. Опционално можем да
          кръщаваме функции си както в
          <a href="#code-snippet-2">код снипет 2</a> - в случая <b>$add</b>. По
          същия начин опционално можем да кръщаваме параметрите на функция - в
          случая <b>$a</b> и <b>$b</b>. В противен случай <b>$a</b> и
          <b>$b</b> се достъпват с <b>0</b> и <b>1</b>.
        </p>
        <br />
        <p>
          В <a href="#table-1">таблица 1</a> са показани част инструкциите в
          WAT. В таблицата са показани операции само за i32, но същите операции
          същестуват за i64, f32 и f64. Булевите операции получават i32 като
          аргументи, където <b>0</b> се приема за <b>false</b> и
          <b>всяко друго цяло число</b> за <b>true</b>. В таблицата също няма да
          сложим инстукциите <b>if</b>,<b>else</b>, <b>end</b>, <b>loop</b> и
          <b>call</b> - тях ще ги разгледаме в примерите
        </p>
        <figure id="table-1">
          <table>
            <thead>
              <tr>
                <th>Инстр.</th>
                <th>Аргум.</th>
                <th>Резултат</th>
                <th>Описание</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>local.get</td>
                <td>индекс или име на локална променлива</td>
                <td>стойността на локалната променлива</td>
                <td>Бута стойността на локална променлива на стека</td>
              </tr>
              <tr>
                <td>local.set</td>
                <td>индекс или име на локална променлива</td>
                <td>няма</td>
                <td>
                  Дърпа стойност от стека и я записва в локалната променлива
                </td>
              </tr>
              <tr>
                <td>global.get</td>
                <td>индекс или име на глобална променлива</td>
                <td>стойността на глобалната променлива</td>
                <td>Бута стойността на глобалната променлива на стека</td>
              </tr>
              <tr>
                <td>global.set</td>
                <td>индекс или име на глобална променлива</td>
                <td>няма</td>
                <td>
                  Дърпа стойност от стека и я записва в глобалната променлива
                </td>
              </tr>
              <tr>
                <td>i32.const</td>
                <td>immediate i32</td>
                <td>i32</td>
                <td>Бута i32 константа на стека</td>
              </tr>
              <tr>
                <td>i64.const</td>
                <td>immediate i64</td>
                <td>i64</td>
                <td>Бута i64 константа на стека</td>
              </tr>
              <tr>
                <td>f32.const</td>
                <td>immediate f32</td>
                <td>f32</td>
                <td>Бута f32 константа на стека</td>
              </tr>
              <tr>
                <td>f64.const</td>
                <td>immediate f64</td>
                <td>f64</td>
                <td>Бута f64 константа на стека</td>
              </tr>
              <tr>
                <td>i32.add</td>
                <td>(i32, i32)</td>
                <td>i32</td>
                <td>Дърпа две i32 стойности от стека и бута сбора им</td>
              </tr>
              <tr>
                <td>i32.sub</td>
                <td>(i32, i32)</td>
                <td>i32</td>
                <td>Дърпа две i32 стойности от стека и бута разликата им</td>
              </tr>
              <tr>
                <td>i32.mul</td>
                <td>(i32, i32)</td>
                <td>i32</td>
                <td>Дърпа две i32 стойности от стека и бута произдението им</td>
              </tr>
              <tr>
                <td>i32.div_s</td>
                <td>(i32, i32)</td>
                <td>i32</td>
                <td>
                  Дърпа две i32 стойности със знак от стека и бута частното им
                </td>
              </tr>
              <tr>
                <td>i32.rem_s</td>
                <td>(i32, i32)</td>
                <td>i32</td>
                <td>
                  Дърпа две i32 стойности със знак от стека и бута остатъка им
                </td>
              </tr>
              <tr>
                <td>i32.rem_s</td>
                <td>(i32, i32)</td>
                <td>i32</td>
                <td>
                  Дърпа две i32 стойности със знак от стека и бута остатъка им
                </td>
              </tr>
              <tr>
                <td>i32.eq</td>
                <td>(i32, i32)</td>
                <td>i32(0/1)</td>
                <td>
                  Дърпа две i32 стойности от стека и бута резултата от
                  проверката за равенство им
                </td>
              </tr>
              <tr>
                <td>i32.ne</td>
                <td>(i32, i32)</td>
                <td>i32(0/1)</td>
                <td>
                  Дърпа две i32 стойности от стека и бута резултата от
                  проверката за неравенството им
                </td>
              </tr>
              <tr>
                <td>i32.lt_s</td>
                <td>(i32, i32)</td>
                <td>i32(0/1)</td>
                <td>
                  Дърпа две i32 стойности със знак от стека и бута резултата от
                  проверката за по-малко
                </td>
              </tr>
              <tr>
                <td>i32.gt_s</td>
                <td>(i32, i32)</td>
                <td>i32(0/1)</td>
                <td>
                  Дърпа две i32 стойности със знак от стека и бута резултата от
                  проверката за по-голямо
                </td>
              </tr>
              <tr>
                <td>i32.eqz</td>
                <td>i32</td>
                <td>i32(0/1)</td>
                <td>
                  Дърпa i32 стойнос от стека и бута резултата от логическа
                  негация
                </td>
              </tr>
              <tr>
                <td>i32.and</td>
                <td>(i32, i32)</td>
                <td>i32</td>
                <td>
                  Дърпа две i32 стойности от стека и бута резултата от побитово
                  и, ако аргументи са 0/1 действа като логически и
                </td>
              </tr>
              <tr>
                <td>i32.or</td>
                <td>(i32, i32)</td>
                <td>i32</td>
                <td>
                  Дърпа две i32 стойности от стека и бута резултата от побитово
                  или, ако аргументи са 0/1 действа като логически или
                </td>
              </tr>
              <tr>
                <td>i32.load</td>
                <td>i32/i64 адрес в памета</td>
                <td>i32</td>
                <td>Взема стойност от памета и я бута на стека</td>
              </tr>
              <tr>
                <td>i32.store</td>
                <td>i32/i64 адрес в памета</td>
                <td>няма</td>
                <td>Дърпа стойност от стека и я записва в памета</td>
              </tr>
            </tbody>
          </table>
          <figcaption>Таблица 1 - WAT инструкции</figcaption>
        </figure>
        <p>
          За да позволим на host средата да извиква функции, които сме
          дефинирали в Wasm, трябва да ги експортнем.
          <a href="#code-snippet-3">Код снипет 3</a> показва как експортнем
          функцията $add под името add.
        </p>
        <figure id="code-snippet-3">
          <pre><code>(module
  (func $add (param $a i32) (param $b i32) (result i32)
    local.get $a  ;; $a е 32-битово цяло число и го бутаме на стека
    local.get $b  ;; същото се отнася за $b
                  ;; тази инстукция дърпа двете най-горни стойности 
                  ;; и ги събира като бута резултата на върха на стека
                  ;; функцията "връща" сбора, понеже той е най-горния 
     i32.add      ;; елемент на стека
  )
  ;; експортва функцията $add под името add
  (export "add" (func $add))  
)</code></pre>
          <figcaption>Код снипет 3 - Експортване на функции</figcaption>
        </figure>
        <p>
          В някой случай бихме искали Wasm да взаимодейства директно host
          средата (в случая JavaScript). Това може да се постигне като импортнем
          функция от host средата. в
          <a href="#code-snippet-4">код снипет 4</a> ще импортнем функция, която
          ще ни позволи, да покажем резултата от събиране директно в DOM-a
        </p>
        <figure id="code-snippet-4">
          <pre><code>(module
  ;; импортваме функция от js,
  ;; която ще принтира i32
  ;; на DOM-a
  (import "js" "print" (func $print (param i32))) 
  (func $add (param $a i32) (param $b i32)
    local.get $a  ;; $a е 32-битово цяло число и го бутаме на стека
    local.get $b  ;; същото се отнася за $b
                  ;; тази инстукция дърпа двете най-горни стойности 
                  ;; и ги събира като бута резултата на върха на стека
                  ;; функцията "връща" сбора, понеже той е най-горния 
     i32.add      ;; елемент на стека
     call $print    ;; извиква импортната функция с аргумент сбора
  )
  ;; експортва функцията $add под името add
  (export "add" (func $add))  
)</code></pre>
          <figcaption>Код снипет 4 - Импортиране на функции</figcaption>
        </figure>
        <figure id="form-1">
          <form id="print-add-form">
            <div>
              <input name="a" type="number" value="2" />
              <input name="b" type="number" value="3" />
            </div>
            <p id="result">Резултат:</p>
            <button>Събери</button>
          </form>
          <figcaption>
            Форма 1 - Събиране и принтиране с импортната функция
          </figcaption>
        </figure>
        <p>
          <a href="#form-1">Форма 1</a> демонстрира кода от
          <a href="#code-snippet-4">код снипет 4</a>
        </p>
        <br />
        <p>
          В Wasm може да викаме не само импортнати функции, но и такива, които
          ние сме декларирали (включително рекурсивно). В
          <a href="#code-snippet-5">код снипет 5</a> ще разгледаме как би
          изглеждала една рекурсивна имплементация на числата на Фибоначи
        </p>
        <figure id="code-snippet-5">
          <pre><code>(module
    ;; импортваме функция, която изчиства списъка от резултати
    ;; няма параметри и не връща нищо
    (import "js" "clear" (func $clear))
    ;; импортваме функция, която добавя число в списъка
    ;; от резултати
    (import "js" "print"  (func $print (param i32)))
    ;; декларираме функция, която смята
    ;; n-то числи на Фибоначи
    (func $fibb (param $n i32) (result i32)
        local.get $n    ;; бута n на стека
        i32.const 0     ;; бута константата 0 на стека
        i32.eq          ;; сравнява n и 0,ако n==0 бута 1, иначе бута 0

        local.get $n    ;; бута n на стека
        i32.const 1     ;; бута константата 1 на стека
        i32.eq          ;; сравнява n и 1,ако n==1 бута 1, иначе бута 0
                        ;; в момента на стека са резултата от n==0 и n==1
        i32.or          ;; прави or на тези двата резултата и го бута на стека

                        ;; проверява дали върха на стека е различен от 0. 
        if (result i32) ;; трябва да кажем какъв е резултата понеже wasm е типизиран
                        ;; тук влиза, ако n==0 || n==1
            i32.const 1 ;; бута 1 на стека и понеже if е последната инструкция, то и връща 1
        else
                        ;; тук влиза, ако не е в сприрачката на рекурсията
            local.get $n;; бута n на стека
            i32.const 1 ;; бута 1 на стека
            i32.sub     ;; смята n-1 и го слага на стека
            call $fibb  ;; прави рекурсивно извикване на fibb(n-1)

            local.get $n;; бута n на стека
            i32.const 2 ;; бута 2 на стека
            i32.sub     ;; смята n-2 и го слага на стека
            call $fibb  ;; прави рекурсивно извикване на fibb(n-2)
                        ;; в момента на стека има две стойности fibb(n-1) и fibb(n-2)
                        ;; събира резултата на fibb(n-1) и резултата на fibb(n-2)
            i32.add     ;; и понеже това е последната операция това се връщa
        end
    )
    ;; функция, която принтира първите n числа на Фибоначи
    ;; (local $i i32) декларира, че функция има една локална променлива
    (func $nfibb (param $n i32) (local $i i32)
        call $clear ;; изчистваме стария списък от резултати

        local.get $n          ;; бута стойността на $n на стека
        i32.const 1           ;; бута 1 на стека
        i32.ge_s              ;; сравнява 1 и n,ако 1<=$n бута 1, иначе бута 0

        if                    ;; проверява дали върха на стека е различен от 0. 
                              ;; влиза тук, ако 1 <= $n, тоест има поне една итерация

            i32.const 1       ;; бута 1 на стека
            local.set $i      ;; инициализираме $i със стойност 1
                              ;; започва цикъл
            loop $loop        ;; слагаме за да можем по-лесно да работим цикъла

                ;; тялото на цикъла започва от тук
                local.get $i  ;; бута стойността на $i на стека
                              ;; дърпа стойността на $i                         
                call $fibb    ;; и бута стойността на i-то числото на Фибоначи
                call $print   ;; дърпа числото на Фибоначи и го принтира
                ;; тялото на цикъла свършва тук
                ;; еквивалентно на print(fibb(i))

                ;; увличава $i с 1
                local.get $i ;; бута стойността на $i на стека
                i32.const 1  ;; бута 1 на стела
                i32.add      ;; събира ги
                local.set $i ;; дърпа сбора от стека и го запазва в $i

                ;; проверява дали $i <= $n
                local.get $n;; бута стойността на $n на стека
                local.get $i;; бута стойността на $i на стека
                i32.ge_s    ;; сравнява $i и $n и бута 1, ако $i<=$n, иначе бута 0

                br_if $loop ;; продължава цикъла, ако $i <= $n
            end
        end
    )
    (export "nfibb" (func $nfibb));; експортваме функцията fibb за да можем да я викнем от javascript
)</code></pre>
          <figcaption>Код снипет 5 - Първите n числа на Фибоначи</figcaption>
        </figure>
        <figure id="form-2">
          <form id="fibb-form">
            <div>
              <input name="n" type="number" value="10" />
            </div>
            <ol id="result"></ol>
            <button>Пресметни</button>
          </form>
          <figcaption>Форма 2 - Изчисли до n-то число на Фибоначи</figcaption>
        </figure>
        <p>
          <a href="#form-2">Форма 2</a> демонстрира кода от
          <a href="#code-snippet-5">код снипет 5</a>. Забележка: не пробвайте
          със стойности по-големи от 45, защото табът най-вероятно ще крашне
        </p>
        <br />
        <p>
          За да позволим на Wasm да работи с по-сложни данни от числа, трябва да
          създадем памет, на която да се съхраняват. В
          <a href="#code-snippet-6">код снипет 6</a> ще създадем памет (linear
          memory) и ще покажем функция, която поздравява по дадено име.
        </p>
        <figure id="code-snippet-6">
          <pre><code>(module
    ;; импортваме функция от js,
    ;; която ще принтира поздрава на DOM-a
    (import "js" "print" (func $print (param i32))) 
    ;; декларираме помощна функция, която да копира данни от едно място
    ;; на друго, подобна функция съществува в C
    ;; тялото е еквивалент на
    ;; for (int i = 0; i < len; i++) {
    ;;      dst[i] = src[i];
    ;; }
    (func $memcpy (param $dst i32) (param $src i32) (param $len i32)
        (local $i i32) (local $byte i32)    ;; декларираме локална променлива $i iи $byte

        i32.const 0           ;; бута 0 на стека
        local.set $i          ;; инициализираме $i със стойност 0

        local.get $len        ;; бута стойността на $len на стека
        local.get $i          ;; бута 0 на стека
        i32.gt_s              ;; сравнява $i и $len, ако $i<$len бута 1, иначе бута 0

        if                    ;; проверява дали върха на стека е различен от 0. 
                              ;; влиза тук, ако $i < $n, тоест има поне една итерация
                              ;; започва цикъл
            loop $loop        ;; слагаме за да можем по-лесно да работим цикъла

                ;; тялото на цикъла започва от тук
                local.get $i  ;; бута стойността на $i на стека
                local.get $src;; бута стойността на $src на стека
                i32.add       ;; събира ги, src+i е адреса на текущия байт в паметта

                              ;; дърпа стойността на src+i от стека 
                i32.load8_u   ;; и бута стойността на текищия байта на стека
                local.set $byte;; запазва в текужия байт в $byte

                local.get $i  ;; бута стойността на $i на стека
                local.get $dst;; бута стойността на $dst на стека
                              ;; събира ги, dst+i е адреса, 
                i32.add       ;; където трябва да запишем текущия байт
                local.get $byte ;; бута стойността на текущия байт на стека
                              ;; дърпа стойнстта на текущия байт от стека
                i32.store8    ;; я записва в паметта на адрес dst+i
                ;; тялото на цикъла свършва тук
                ;; еквивалентно на dst[i] = src[i]

                ;; увличава $i с 1
                local.get $i ;; бута стойността на $i на стека
                i32.const 1  ;; бута 1 на стела
                i32.add      ;; събира ги
                local.set $i ;; дърпа сбора от стека и го запазва в $i

                ;; проверява дали $i < $len
                local.get $len;; бута стойността на $n на стека
                local.get $i;; бута стойността на $i на стека
                i32.gt_s    ;; сравнява $i и $n и бута 1, ако $i<$len, иначе бута 0

                br_if $loop ;; продължава цикъла, ако $i < $len
            end
        end
    )

    ;; деклалираме функция $greet, която получава указател до началото
    ;; на името и дължината името в байтове и връща адреса на
    ;; новия низ в памета. i32 се използва като указател тук
    (func $greet (param $namePtr i32) (param $nameLen i32)
        ;; декларираме една локална променлива, която ще служи като
        ;; указател към резултата
        (local $resultPtr i32)
       
        i32.const 16384     ;; бута 16384 на стека
        local.set $resultPtr;; записва 16384 в локалната променлива

        local.get $resultPtr;; бутаме адреса на резултата на стека
        i32.const 0         ;; 0 е адреса на "Здравей, "
        i32.const 16        ;; 20 е размера на "Здрвей, "
        call $memcpy        ;; копира "Здравей, " в резултата

        local.get $resultPtr;; бутаме адреса на резултата на стека
        i32.const 16        ;; бутаме константата 16 на стека
                            ;; събираме ги, понеже вече "Здравей, " 
                            ;; е записан в резултата, трябва да продължи   
        i32.add             ;; на следващия свободен байт, и именно  $resultPtr + 16
        local.get $namePtr  ;; бута адреса на името на стека
        local.get $nameLen  ;; бута дължината на името на стека
        call $memcpy

        local.get $resultPtr
        call $print
    )
    ;; деклалираме памет с големина 64 килобайта
    ;; разположението в паметта е изцяло по преценка на автора
    ;; низови константи като "Здравей, " ще се съхраняват в адресите [0, 128)
    ;; входен низ (името) ще се съхраняват в адресите [128, 16384)
    ;; резултатен низ (поздрава) ще се съхранява в адресите [16384, 65536)
    (memory $memory 1)
    (data (i32.const 0) "Здравей, ")

    (export "greet" (func $greet))
    (export "memory" (memory $memory))
)</code></pre>
          <figcaption>Код снипет 6 - Програма, която поздравява</figcaption>
        </figure>
        <figure id="form-3">
          <form id="greet-form">
            <div>
              <input name="name" type="text" value="Дидак" />
            </div>
            <p id="result">Резултат:</p>
            <button>Поздрави</button>
          </form>
          <figcaption>Форма 3 - Поздрав от Wasm</figcaption>
        </figure>
        <p>
          <a href="#form-3">Форма 3</a> демонстрира кода от
          <a href="#code-snippet-6">код снипет 6</a>.
        </p>
      </section>
      <hr />
      <section id="wasm-as-compilation-target">
        <h2>WebAssembly като цел за компилация</h2>
        <p>
          В секция <a href="#wat">Wat</a> разгледахме няколко примера за Wasm,
          но също можем да забележим, че кода става доста труден за четене дори
          за прости програми с една или две функции. На практика почти никой не
          пише Wasm на ръка. Вместо това използват други езици, които могат да
          се компилират да WebAssembly. В момента за почти всеки от известените
          езици съществува компилатор за Wasm, но езиците, които най-често се
          ползват са C++ и Rust.
        </p>
        <br />
        <p>
          C++ изпозва
          <a
            href="https://emscripten.org/docs/introducing_emscripten/index.html"
            >Emscripten</a
          >който най-често служи за пренасяне на съществуващи стари проекти към
          WebAssembly, както и за компилиране на видео игри, които искаме да
          работят в браузъра.
        </p>
        <br />
        <p>
          Rust изпозва
          <a href="https://drager.github.io/wasm-pack/">wasm-pack</a>. Rust
          използва wasm-pack. Rust предоставя най-добрата екосистема за
          WebAssembly към момента на създаването на този реферат. Компилаторът
          може директно да компилира Rust код до Wasm, а екосистемата включва
          множество полезни библиотеки, като wasm-bindgen. Поради тези причини
          ще използваме Rust, за да демонстрираме предимствата на Wasm с един
          по-голям пример. Примерът ще бъде Solver на известната игра 8-puzzle:
        </p>
        <article id="board-wrapper">
          <div id="board">
            <div id="cell-1" class="cell"></div>
            <div id="cell-2" class="cell"></div>
            <div id="cell-3" class="cell"></div>
            <div id="cell-4" class="cell"></div>
            <div id="cell-5" class="cell"></div>
            <div id="cell-6" class="cell"></div>
            <div id="cell-7" class="cell"></div>
            <div id="cell-8" class="cell"></div>
            <div id="cell-9" class="cell"></div>
          </div>
          <div id="btns">
            <button id="shuffle-board-btn">Разбъркай</button>
            <button id="solve-board-btn">Реши</button>
          </div>
        </article>
      </section>
    </main>
    <footer>
      <p>
        Целият код е достъпен в
        <a href="https://github.com/lastvoidtemplar/web-referat">Github</a> за
        тези, които искат да разгледат javascript или rust кода.
      </p>
      <p>Авторът не е виновен, ако браузърът или устройството ви хвърли боба</p>
      <p></p>
    </footer>
  </body>
</html>
